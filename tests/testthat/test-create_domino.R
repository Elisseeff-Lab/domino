## unit tests use internal data stored in R/create_domino.R

test_that(
  "select_cluster_tf: identify differntial feature scores by one-sided wilcox test", {
    set.seed(123)
    cell_ids <- paste("cell", seq(300), sep = "_")
    clusters_tiny <- factor(
      c(rep("A", 100), rep("B", 100), rep("C", 100))
    )
    names(clusters_tiny) <- cell_ids
    # there are 5 TF features
    # feature scores are between 0 and 1, generated by a poisson distribution
    # TF1 is associated with cluster A
    # TF2 is associated with cluster B
    # TF3 is associated with cluster C
    # TF4 has even elevated scores across clusters
    # TF5 has 0 score across clusters
    
    simulate_poisson <- function(n, betaA, betaB, betaC) {
      id <- seq_along(3*n)
      cluster <- c(rep("A", n), rep("B", n), rep("C", n))
      E <- t(matrix(
        c(
          rep(c(1, 0, 0), n), # effect of cluster A
          rep(c(0, 1, 0), n), # effect of cluster B
          rep(c(0, 0, 1), n) # effect of cluster C
        ), 
        nrow = 3, ncol = 3 * n))
      mu <- exp(0 + betaA * E[,1] +  betaB * E[,2] +  betaC * E[,3])
      Y <- rpois(n = 3 * n, lambda = mu)
      # scale Y between values of 0 and 1
      Y_scale <- ((Y - min(Y)) / max(Y))
      df <- data.frame(
        "id" = id,
        "cluster" = cluster,
        "Y" = Y,
        "Y_scale" = Y_scale
      )
      return(df)
    }
    
    TF1 <- simulate_poisson(n = 100, betaA = 5, betaB = 1, betaC = 1)[["Y_scale"]]
    TF2 <- simulate_poisson(n = 100, betaA = 1, betaB = 5, betaC = 1)[["Y_scale"]]
    TF3 <- simulate_poisson(n = 100, betaA = 1, betaB = 1, betaC = 5)[["Y_scale"]]
    TF4 <- simulate_poisson(n = 100, betaA = 3, betaB = 3, betaC = 3)[["Y_scale"]]
    TF5 <- simulate_poisson(n = 100, betaA = 0, betaB = 0, betaC = 0)[["Y_scale"]]
    
    features_tiny <- t(matrix(
      c(TF1, TF2, TF3, TF4, TF5),
      ncol = 5, nrow = 300, 
      dimnames = list(
        cell_ids, 
        c("TF1", "TF2", "TF3", "TF4", "TF5")
      )
    ))
    
    tf_pval_mat <- select_cluster_tf(
      features = features_tiny, clusters = clusters_tiny, 
      verbose = FALSE, method = "one.sided.wilcox"
    )
    expect_true(tf_pval_mat["TF1", "A"] < 0.05)
    expect_true(tf_pval_mat["TF2", "B"] < 0.05)
    expect_true(tf_pval_mat["TF3", "C"] < 0.05)
    expect_true(sum(tf_pval_mat["TF4",] < 0.05) == 0) 
    expect_true(sum(tf_pval_mat["TF5",] < 0.05) == 0)
  }
)

test_that(
  "write_rec_lig_linkages: generate list of receptors capable of interacting with receptors", {
    rl_parse_tiny <- data.frame(
      "R.gene" = c("GENEB1,GENEB2", "GENEC", "GENEC", "GENEB1,GENEB2", "GENEE1,GENEE2"),
      "L.gene" = c("GENEA", "GENEA", "GENED1,GENED2", "GENED1,GENED2", "GENEF"),
      "R.name" = c("complexB", "GENEC", "GENEC", "complexB", "complexE"),
      "L.name" = c("GENEA", "GENEA", "complexD", "complexD", "GENEF")
    )
    
    expected_rec_lig <- list(
      "complexB" = c("GENEA", "complexD"),
      "GENEC" = c("GENEA", "complexD"),
      "complexE" = c("GENEF")
    )
    
    expect_equal(
      write_rec_lig_linkages(rl_parse_tiny),
      expected_rec_lig
    )
  }
)
test_that(
  "read_rl_map_complexes: generate list of annotated complexes", {
    rl_parse_tiny <- data.frame(
      "R.gene" = c("GENEB1,GENEB2", "GENEC", "GENEC", "GENEB1,GENEB2"),
      "L.gene" = c("GENEA", "GENEA", "GENED1,GENED2", "GENED1,GENED2"),
      "R.name" = c("complexB", "GENEC", "GENEC", "complexB"),
      "L.name" = c("GENEA", "GENEA", "complexD", "complexD")
    )
    expected_complex_list <- list(
      "complexD" = c("GENED1", "GENED2"),
      "complexB" = c("GENEB1", "GENEB2")
    )
    expect_equal(
      read_rl_map_complexes(rl_parse_tiny, use_complexes = TRUE),
      expected_complex_list
    )
    expect_equal(
      read_rl_map_complexes(rl_parse_tiny, use_complexes = FALSE),
      NULL
    )
  }
)
test_that(
  "read_rl_map_complexes: warning that complexes with the same name have different components", {
    rl_parse_repeated <- data.frame(
      "R.gene" = c("GENEB1,GENEB2", "GENEB1,GENEB3"),
      "L.gene" = c("GENEA", "GENEA"),
      "R.name" = c("complexB", "complexB"),
      "L.name" = c("GENEA", "GENEA")
    )
    expect_warning(read_rl_map_complexes(rl_parse_repeated, use_complexes = TRUE))
  }
)
test_that(
  "read_rl_map_genes: Convert rl_map to columns stored in dom@misc$rl_map", {
    rl_map_tiny <- data.frame(
      gene_A = c("GENEA", "GENEA"),
      protein_A = c("simpleA", "simpleA"),
      type_A = c("L", "L"),
      name_A = c("GENEA", "GENEA"),
      gene_B = c("GENEB1,GENEB2", "GENEC"),
      protein_B = c("complexB1,complexB2", "simpleC"),
      type_B = c("R", "R"),
      name_B = c("complexB", "GENEC"),
      int_pair = c("GENEA & complexB", "GENEA & GENEC"),
      annotation_strategy = c("test", "test"),
      source = c("test", "test"),
      database_name = c("CellPhoneDB", "CellPhoneDB")
    )
    expected_rl_parse <- data.frame(
      "R.gene" = c("GENEB1,GENEB2", "GENEC"),
      "L.gene" = c("GENEA", "GENEA"),
      "R.name" = c("complexB", "GENEC"),
      "L.name" = c("GENEA", "GENEA")
    )
    expect_equal(
      read_rl_map_genes(rl_map_tiny),
      expected_rl_parse
    )
  }
)
